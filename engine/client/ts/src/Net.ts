const NET_SIMULATION_PING = 0; //rtt/2 ms
const SIZEOF_USIZE32 = 4; //32 bits = 4 bytes

type InitializingNetState = {
	transport: WebTransport;
	open: boolean;
	onDisconnect: [() => void];
};

export type NetState = Awaited<ReturnType<typeof init>>;

export async function init() {
	const devcert: number[] = JSON.parse(await (await fetch("/devcert.json")).text()); //this is autogenerated by the server when it starts
	const transport = new WebTransport(`https://${location.hostname}:6969`, {
		serverCertificateHashes: [
			{
				algorithm: "sha-256",
				value: new Uint8Array(devcert),
			},
		],
	});

	const uninitNet: InitializingNetState = {
		transport,
		open: true,
		onDisconnect: [() => {}],
	};

	listenOnClose(uninitNet);
	await listenOnOpen(uninitNet);

	const simulationStream = await transport.createBidirectionalStream();
	const stateStream = listenForState(simulationStream.readable.getReader());
	const inputStream = simulationStream.writable.getWriter();

	if (NET_SIMULATION_PING > 0) {
		const laggyWrite = inputStream.write.bind(inputStream);
		inputStream.write = async function (chunk) {
			await new Promise((resolve) => setTimeout(resolve, NET_SIMULATION_PING));
			laggyWrite(chunk);
		};
	}

	//the first packet is needed to init the simulation.
	//it is a snapshot of the current game state
	const newClientSnapshot = (await stateStream.next()).value!;

	return {
		...uninitNet,
		stateStream,
		inputStream,
		newClientSnapshot,
	};
}

//do not await this. it is an infinite loop
export async function onStateReceived(net: NetState, cb: (stateBuffer: Uint8Array) => void) {
	while (true) cb((await net.stateStream.next()).value!);
}

export function onDisconnect(net: NetState, cb: () => void) {
	//note this is a tuple so that the change propogates to both
	//the current NetState and the original InitializingNetState
	net.onDisconnect[0] = cb;
}

async function listenOnOpen(net: InitializingNetState) {
	try {
		await net.transport.ready;
	} catch (oops) {
		onClose(net, { reason: String(oops) });
		throw oops;
	}
}

//the equivalent "listen_for_input" happens in rust
async function* listenForState(stateStream: ReadableStreamDefaultReader) {
	let excess = new Uint8Array();

	while (true) {
		//receive number of bytes in server's simulation state diff
		const stateSizeBytes = await receivePacket(stateStream, SIZEOF_USIZE32, excess);
		const stateSize = new DataView(stateSizeBytes.packet.buffer).getUint32(0, true);
		excess = stateSizeBytes.excess;

		const stateBytes = await receivePacket(stateStream, stateSize, excess);
		excess = stateBytes.excess;
		yield stateBytes.packet;
	}
}

async function listenOnClose(net: InitializingNetState) {
	let closeInfo;
	try {
		closeInfo = await net.transport.closed;
	} catch (oops) {
		closeInfo = { reason: String(oops) };
	}

	onClose(net, closeInfo);
}

function onClose(net: InitializingNetState, oops: WebTransportCloseInfo) {
	if (!net.open) return;
	net.open = false;
	net.transport.close();
	net.onDisconnect[0]();

	oops.reason = oops.reason?.trim(); //sometimes it's nothing but whitespace?
	const reason = oops.reason ? `: ${oops.reason ?? ""}` : "";
	const code = oops.closeCode !== undefined ? ` (WebTransport error code ${oops.closeCode})` : "";
	const full = `Lost connection to game server${reason}${code}`;

	//the tab is now borked. need proper error handling
	alert(full);
}

//stoopid api doesn't let you request to read
//a fixed number of bytes, so prvExcessBuffer
//is needed to hold onto whatever extra bytes
//were uncontrollably vomited
async function receivePacket(
	stream: ReadableStreamDefaultReader,
	size: number,
	prvExcessBuffer: Uint8Array<ArrayBuffer>,
) {
	const packetBuffer = new Uint8Array(size);
	packetBuffer.set(prvExcessBuffer.subarray(0, size));
	let progress = prvExcessBuffer.length;

	let newExcessBuffer: typeof prvExcessBuffer;
	if (progress >= size) {
		newExcessBuffer = prvExcessBuffer.subarray(size);
	} else {
		while (progress < size) {
			if (NET_SIMULATION_PING > 0)
				await new Promise((resolve) => setTimeout(resolve, NET_SIMULATION_PING));

			const result = await stream.read();
			if (result.done) throw Error("State stream closed");

			const needMore = size - progress;
			packetBuffer.set(result.value.subarray(0, needMore), progress);
			progress += result.value.length;

			if (progress >= size) newExcessBuffer = result.value.subarray(needMore);
		}
	}

	return { packet: packetBuffer, excess: newExcessBuffer! };
}
