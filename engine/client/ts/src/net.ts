//these should not be hardcoded obviously. temporary
const PORT_WEBTRANSPORT = 6969;
const PORT_WEBSOCKET = 6996;

const NET_SIMULATION_PING = 0; //rtt/2 ms
const NET_TIMEOUT = 10; //kill a connection after this many seconds of lag. should match net.rs
const SIZEOF_USIZE32 = 4; //32 bits = 4 bytes

type InitializingNetState = WTInitializingNetState | WSInitializingNetState;

type WTInitializingNetState = {
	transport: WebTransport;
} & InitializingNetStateRest;

type WSInitializingNetState = {
	transport: WebSocket;
} & InitializingNetStateRest;

type InitializingNetStateRest = {
	established: boolean;
	open: boolean;
	onDisconnect: [() => void];
};

export type NetState = Awaited<ReturnType<typeof init>>;

export async function init(useWebTransport: boolean) {
	let net: InitializingNetState;
	let stateStream: AsyncGenerator<Uint8Array, void, unknown>;
	let writeInput: (stateBytes: Uint8Array) => void;

	if (useWebTransport) {
		const config: WebTransportOptions = {};
		if (import.meta.env.DEV) {
			//this is autogenerated by the dev server when it starts
			const devcert: number[] = JSON.parse(await (await fetch("/devcert.json")).text());
			config.serverCertificateHashes = [{ algorithm: "sha-256", value: new Uint8Array(devcert) }];
		}

		const transport = new WebTransport(`https://${location.hostname}:${PORT_WEBTRANSPORT}`, config);

		net = {
			transport,
			established: false,
			open: true,
			onDisconnect: [() => {}],
		};

		wtListenOnDisconnect(net);

		try {
			await net.transport.ready;
		} catch (oops) {
			triggerDisconnect(net, { reason: String(oops) });
			throw oops;
		}

		net.established = true;

		const simulationStream = await transport.createBidirectionalStream();
		stateStream = wtListenForState(simulationStream.readable.getReader());
		const inputStream = simulationStream.writable.getWriter();
		writeInput = function (stateBytes) {
			//write the number of bytes being sent
			const stateSizeBytes = new ArrayBuffer(SIZEOF_USIZE32);
			new DataView(stateSizeBytes).setUint32(0, stateBytes.byteLength, true);

			inputStream.write(stateSizeBytes);
			inputStream.write(stateBytes);
		};
	} else {
		const ws = new WebSocket(`wss://${location.hostname}:${PORT_WEBSOCKET}`);
		ws.binaryType = "arraybuffer";

		net = {
			transport: ws,
			established: false,
			open: true,
			onDisconnect: [() => {}],
		};

		ws.onclose = function (e) {
			triggerDisconnect(net, { reason: e.reason, closeCode: e.code });
		};

		await new Promise<void>((resolve) => (ws.onopen = () => resolve()));
		net.established = true;

		stateStream = wsListenForState(net);
		writeInput = ws.send.bind(ws);
	}

	if (NET_SIMULATION_PING > 0) {
		const ogWriteInput = writeInput;
		writeInput = async function (chunk) {
			await new Promise((resolve) => setTimeout(resolve, NET_SIMULATION_PING));
			ogWriteInput(chunk);
		};
	}

	//the first packet is needed to init the simulation.
	//it is a snapshot of the current game state
	const newClientSnapshot = (await stateStream.next()).value!;

	return {
		transport: net.transport,
		newClientSnapshot,
		writeInput,
		stateStream,
		onDisconnect: net.onDisconnect,
	};
}

//do not await this. it is an infinite loop
export async function onStateReceived(net: NetState, cb: (stateBuffer: Uint8Array) => void) {
	while (true) cb((await net.stateStream.next()).value!);
}

export function onDisconnect(net: NetState, cb: () => void) {
	//note this is a tuple so that the change propogates to both
	//the current NetState and the original InitializingNetState
	net.onDisconnect[0] = cb;
}

function triggerDisconnect(net: InitializingNetState, oops: WebTransportCloseInfo) {
	if (!net.open) return;
	net.open = false;
	net.transport.close();

	try {
		net.onDisconnect[0]();
	} catch (oops) {
		//eslint-disable-next-line no-console
		console.error(oops);
	}

	const isWebSocket = net.transport instanceof WebSocket;
	if (isWebSocket && !net.established && import.meta.env.DEV) {
		if (
			confirm(
				"Lost connection to game server. Your browser may be blocking the WSS connection due to the server using self-signed certificates. Click OK to check.",
			)
		) {
			//using setInterval in an attempt to give the browser
			//more time to add the current vite page to its history.
			//sometimes since the page doesn't fully load before this
			//redirect, it doesn't get added. the websocket page
			//attempts to go back 1 page in history after dismissing
			//the cert warning so it needs to be in there
			setInterval(() => (location.href = `https://${location.hostname}:${PORT_WEBSOCKET}`), 500);
		}
	} else {
		oops.reason = oops.reason?.trim(); //sometimes it's nothing but whitespace?
		const reason = oops.reason ? `: ${oops.reason ?? ""}` : "";
		const protocol = isWebSocket ? "WebSocket" : "WebTransport";
		const code = oops.closeCode !== undefined ? ` (${protocol} error code ${oops.closeCode})` : "";
		const full = `Lost connection to game server${reason}${code}`;

		//the tab is now borked. need proper retry handling
		alert(full);
	}
}

//---WEBTRANSPORT---//

//the equivalent "listen_for_input" happens in rust
async function* wtListenForState(stateStream: ReadableStreamDefaultReader) {
	let excess = new Uint8Array();

	while (true) {
		//receive number of bytes in server's simulation state diff
		const stateSizeBytes = await wtReceivePacket(stateStream, SIZEOF_USIZE32, excess);
		const stateSize = new DataView(stateSizeBytes.packet.buffer).getUint32(0, true);
		excess = stateSizeBytes.excess;

		const stateBytes = await wtReceivePacket(stateStream, stateSize, excess);
		excess = stateBytes.excess;
		yield stateBytes.packet;
	}
}

async function wtListenOnDisconnect(net: WTInitializingNetState) {
	let closeInfo;
	try {
		closeInfo = await net.transport.closed;
	} catch (oops) {
		closeInfo = { reason: String(oops) };
	}

	triggerDisconnect(net, closeInfo);
}

//stoopid api doesn't let you request to read
//a fixed number of bytes, so prvExcessBuffer
//is needed to hold onto whatever extra bytes
//were uncontrollably vomited
async function wtReceivePacket(
	stream: ReadableStreamDefaultReader,
	size: number,
	prvExcessBuffer: Uint8Array<ArrayBuffer>,
) {
	const packetBuffer = new Uint8Array(size);
	packetBuffer.set(prvExcessBuffer.subarray(0, size));
	let progress = prvExcessBuffer.length;

	let newExcessBuffer: typeof prvExcessBuffer;
	if (progress >= size) {
		newExcessBuffer = prvExcessBuffer.subarray(size);
	} else {
		while (progress < size) {
			if (NET_SIMULATION_PING > 0)
				await new Promise((resolve) => setTimeout(resolve, NET_SIMULATION_PING));

			const result = await stream.read();
			if (result.done) throw Error("State stream closed");

			const needMore = size - progress;
			packetBuffer.set(result.value.subarray(0, needMore), progress);
			progress += result.value.length;

			if (progress >= size) newExcessBuffer = result.value.subarray(needMore);
		}
	}

	return { packet: packetBuffer, excess: newExcessBuffer! };
}

//---WEBSOCKET---//

async function* wsListenForState(net: WSInitializingNetState) {
	//buffer incoming messages so the async generator can yield them on demand
	const queue: Uint8Array[] = [];
	let resolve: (() => void) | null = null;
	let timeout = wsListenOnDisconnect(net);

	net.transport.onmessage = (e: MessageEvent) => {
		queue.push(new Uint8Array(e.data as ArrayBuffer));
		resolve?.();
		resolve = null;

		clearTimeout(timeout);
		timeout = wsListenOnDisconnect(net);
	};

	while (true) {
		if (queue.length === 0) await new Promise<void>((r) => (resolve = r));
		if (NET_SIMULATION_PING > 0) await new Promise((r) => setTimeout(r, NET_SIMULATION_PING));

		yield queue.shift()!;
	}
}

function wsListenOnDisconnect(net: WSInitializingNetState) {
	return setTimeout(() => triggerDisconnect(net, { reason: "Timed out" }), NET_TIMEOUT * 1000);
}
